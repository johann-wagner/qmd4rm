{
  "hash": "67e5e50f944c3d719d4a9f4d9ab7eeeb",
  "result": {
    "engine": "knitr",
    "markdown": "---\nformat: html\n---\n\n## Goal\n\nWrite a function that can take an input data source (a data frame at this stage) and extract a numeric value from a specific cell. The cell is identified via the column name and filter criteria that uniquely identify the row.\n\nArguments should include:\n\n- `data` - the input data frame, in tidy format\n- `row` - use `filter()` for row selection - no default\n- `column` - use `select()` for column selection - no default\n- `unit` - to define the unit of the value being returned (n, %, other?) - no default?\n- `digits` - define the number of significant digits to round to - default `1`\n- `smallcell` - define the value at which cell suppression occurs - default `FALSE`\n- `allowable_range` - two-value argument defining the upper and lower bounds the value must fall within - default `FALSE`\n\nChecks on input to do:\n\n-   [ ] Is the input numeric? If not, extract digits. If no digits extracted, return error\n-   [ ] Is there more than one numeric value?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_value <- function(\n    data, # The input data \n    column, # The column the value is in\n    criteria, # The filter criteria to identify a singular row\n    digits = 2, # The number of significant digits to round to\n    unit = \"n\", # The units for the value, either n, percent, or a custom value\n    multiply = 1, # Set whether the value is a proportion or percentage\n    suppress = FALSE, # Suppress values smaller than this value\n    allowable_range = FALSE # Set the min and max values the value must be between\n){\n  if(is.data.frame(data)){\n    # Pull the value based on the criteria and column\n  value <- data |> \n    dplyr::filter({{ criteria }}) |> \n    dplyr::pull({{ column }})\n  } else {\n    stop(\"Input data is not a data frame\")\n  }\n  \n  # Check that value is not empty\n  if(length(value) == 0 | is.null(value)){\n    stop(\"No values returned by criteria\")\n  }\n  # Check there are not multiple values returned\n  if(length(value) > 1){\n    stop(\"More than one row was returned by criteria\")\n  }\n  \n  if(class(value) == \"character\") {\n    if(stringr::str_count(value,\"\\\\d+?(\\\\.\\\\d+)\") > 1){\n      stop(\"Multiple possible values detected in cell\")\n    } else if(stringr::str_count(value,\"\\\\d+?(\\\\.\\\\d+)\") == 0){\n      stop(\"No digits detected in cell\")\n    } else {\n      value <- as.numeric(\n        stringr::str_extract(\n          string = value, \n          pattern = \"\\\\d+?(\\\\.\\\\d+)\"\n          )\n        )\n    }\n  } else if(!is.numeric(value)) {\n    stop(\"column is not numeric or character\")\n  }\n  \n  if(unit ==\"percent\"){\n    # Format as a percentage\n    return(\n      scales::label_percent(\n        accuracy = digits,\n        scale = multiply,\n        big.mark = \",\"\n        )(value)\n      )\n  } else {\n    value <- scales::label_number(accuracy = digits, big.mark = \",\")(value)\n  } \n  \n  if(unit == \"n\"){\n    return(value)\n  } else {\n    return(paste0(value, \" \", unit))\n  }\n}\n```\n:::\n\n\n## Example\n\nThe errors and output are demonstrated using the following dataset\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- tibble::tibble(\n  quintile = rep(c(1,1,3,4,5), 2),\n  rurality = c(rep(\"Regional\",5), rep(\"Urban\", 5)),\n  count = rep(c(1251.12,5125.23,6162.12,9949.0125,1661), 2),\n  n_and_pct = rep(c(\"15.6 (12.2%)\",\"1 (0.1%)\",\"51.5 (85.2%)\", \"102 (115%)\", \"223 100%\"), 2),\n  n_n = rep(c(\"15.2 1\", \"61.4 1\", \"61.0 2\", \"32.4 4.2\", \"95.2 15.2\"), 2),\n  pct = rep(c(\"0.12\",\"0.56\"),5),\n  listcol = stringr::str_extract_all(n_and_pct,\"\\\\d\")\n)\n\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 Ã— 7\n   quintile rurality count n_and_pct    n_n       pct   listcol  \n      <dbl> <chr>    <dbl> <chr>        <chr>     <chr> <list>   \n 1        1 Regional 1251. 15.6 (12.2%) 15.2 1    0.12  <chr [6]>\n 2        1 Regional 5125. 1 (0.1%)     61.4 1    0.56  <chr [3]>\n 3        3 Regional 6162. 51.5 (85.2%) 61.0 2    0.12  <chr [6]>\n 4        4 Regional 9949. 102 (115%)   32.4 4.2  0.56  <chr [6]>\n 5        5 Regional 1661  223 100%     95.2 15.2 0.12  <chr [6]>\n 6        1 Urban    1251. 15.6 (12.2%) 15.2 1    0.56  <chr [6]>\n 7        1 Urban    5125. 1 (0.1%)     61.4 1    0.12  <chr [3]>\n 8        3 Urban    6162. 51.5 (85.2%) 61.0 2    0.56  <chr [6]>\n 9        4 Urban    9949. 102 (115%)   32.4 4.2  0.12  <chr [6]>\n10        5 Urban    1661  223 100%     95.2 15.2 0.56  <chr [6]>\n```\n\n\n:::\n:::\n\n\n### Numeric output\n\nReturn a number\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_value(\n  data = df,\n  column = count, # <1>\n  criteria = (rurality == 'Regional' & quintile == 5), # <2>\n  digits = 1.1, # <3>\n  unit = \"n\" # <4>\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1,661\"\n```\n\n\n:::\n:::\n\n\n1.  Which column the value is to come from\n2.  The criteria to filter rows by. Multiple criteria are allowed, they must be written between parentheses and multiple conditions specified using usual logic notation (e.g. `|`, `&`). Note `dplyr::filter()` notation using commas is not allowed\n3.  Using `{scales}` notation to define the expected format. Specifying `digits = 1.1` for a value of 14.61136 would return 14.6, while specifying `digits = 1.11` returns 14.61.\n4.  The unit the value is in. `n` returns the value as it is. `percent` returns a value formatted as a percentage including the `%` sign. Any other string than these two options is pasted at the end. For example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_value(df, count, (rurality == 'Regional' & quintile == 5), 1.1, \"kcal/day\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1,661 kcal/day\"\n```\n\n\n:::\n:::\n\n\n### Percentage output\n\nReturn as percentage \n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_value(\n  data = df,\n  criteria = (rurality == 'Regional' & quintile == 5),\n  column = pct,\n  unit = \"percent\",\n  digits = 1.11,\n  multiply = 100\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"12.21%\"\n```\n\n\n:::\n:::\n\n\nThe number of people living regionally is\n1,660\n\n## Error conditions\n\nThe data argument only accepts data frames and is checked using `is.data.frame(data)`\n\nThe value pulled from the data frame must not be empty `(length(value) == 0 | is.null(value))`\n\nThere must be only one pulled value, meaning list/vector/df columns are not acceptable `length(value) > 1`\n\nThere must not more than one digit value to be extracted `(stringr::str_count(value,\"\\\\d+?(\\\\.\\\\d+)\") > 1)`\n\nThere must not be zero values to extract `(stringr::str_count(value,\"\\\\d+?(\\\\.\\\\d+)\") == 0)`\n\nIf the value is not a character, it must not be a class other than numeric `!is.numeric(value)`\n\n## Further development\n\n1.  Allow for more inputs than data frames, e.g. vectors\n2.  \n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}